/*
 * File:   main.c
  */

#include <xc.h>                 // Include the search_result file needed by the compiler
//#include "pps.h"              // Use PPS.h from project folder (not from library) (datasheet p159)
#include <pps.h>                // Use PPS.h 
#include "hardware.h"
#include "extra.h"
#include "interrupts.h"

#include <stdio.h>
#include <stdlib.h>             // Needed for itoa function
#include <string.h>             // Needed for strncpy function
#include <stdint.h>


// PIC 18F26J13 uses internal oscillator @ 4 Mhz with 4X PLL for 16MHz sys clock
#pragma config WDTEN = OFF, PLLDIV = 2, CFGPLLEN = OFF, STVREN = ON
#pragma config XINST = OFF, CP0 = OFF, OSC = INTOSC, SOSCSEL = DIG
#pragma config CLKOEC = OFF, FCMEN = OFF, IESO = ON, WDTPS = 1024
#pragma config DSWDTOSC = INTOSCREF, RTCOSC = INTOSCREF, DSBOREN = OFF
#pragma config DSWDTEN = ON, DSWDTPS = 2048, IOL1WAY = OFF, ADCSEL = BIT12
#pragma config PLLSEL = PLL4X, MSSP7B_EN = MSK7, WPFP = PAGE_127
#pragma config WPCFG = OFF, WPDIS = OFF, WPEND = PAGE_WPFP


#if defined(USE_UART)
//#include "UART.h"            // use local uart.c & uart.h
#include <usart.h>             // plib Library file
#endif

/*
 * Global variable to request 'light' sleep
 * The default is deep sleep.
 */
volatile unsigned char gRequestLightSleep = 0;

 /****************************************************************************************************
 *
 *  INTERRUPT functions
 *
 ***************************************************************************************************/
void interrupt low_priority LowISR(void)               
{
NOP();
seconds_counter_TMR0();
ILS_Input_Detected();   // RB5 (RP8) is assigned to INT1
SET_Button_IDENT();     // RA5 (RP2) is assigned to INT2
}

        
void interrupt high_priority HighISR(void)
{
NOP();
#if defined(USE_RFM)
HF_Rx_IT();
#endif    
}
/***************************************************************************************************/

extern BOOL TRANSMIT_IDENT;
extern BOOL DOOR_OPEN;
extern BOOL SEND_DOOR_REPORT;


void main(void)
{        
    eWakeReason ResetType;
        
    OSCCON = 0b01100000;    /* Set internal oscillator to 4MHz wit PLL4X as defined in config words */
    OSCTUNEbits.PLLEN = 1;  /* Turn on PLL for a 16MHz system oscillator */

    ResetType = check_reset(); 

    if( (ResetType == eDSWDTO) || (ResetType == eDSWDTO) )
    {
        /* Rstore output pins state on wake from deep sleep */
        LATA = PORTA;       /* On a wake from deep sleep restore the    */
        LATB = PORTB;       /* output data latch state from the current */
        LATC = PORTC;       /* 'frozen' state of the port inputs.       */
    }
    else
    {
        /* set Power On Reset defaults for output pins */
        RFM_SHUTDOWN = 1;        // Keep RFM22 is in shutdown mode
        SLEEP_DC = 1;
        MODE_LED = 0;
        LED = 0;      
        SYSTEM_BLUE_LED = 0;
        RELAY = 0;
        BUZZER = 0;
    }

    // Wait 3 seconds for voltages to stabilize at start-up
    for (int i=0; i<300; i++) __delay_ms(10);
       
    ADCON0 = (0b00000000);   // ADON=0, Channel 0, Disable AD converter
    ANCON0 = (0b11111111);   // DS page 371 Pins configured as a digital port
    ANCON1 = (0b00011111);   // DS page 368 Pins configured as a digital port
    
    CM1CON = 0b00000000;     // Turn off all comparators
    CM2CON = 0b00000000;
    CM3CON = 0b00000000;
    CVRCON = 0b00000000;
    
    /* set output pin directions */
    RELAY_TRIS = 0;    
    BUZZER_TRIS = 0;  
    SYSTEM_BLUE_LED_TRIS = 0;
    LED_TRIS = 0;   
    MODE_LED_TRIS = 0;
    SLEEP_DC_TRIS = 0;
    RFM_SHUTDOWN_TRIS = 0;   // RFM22 shutdown pin is output

    /* set input pin directions */
    ILS_TRIS = 1;  
    IDENT_TRIS = 1;
    INPUT_1_TRIS = 1;
    INPUT_2_TRIS = 1;
    LOW_BAT_TRIS = 1;
    RFM_nIRQ_TRIS = 1;                // nIRQ is an input
     
    /* PIN RE-MAPPING*/
    PPSUnLock();
    PPSInput(PPS_INT1 , PPS_RP8); // [RB5 = ILS CONTACT] (RP8) is assigned to INT1
    PPSInput(PPS_INT2 , PPS_RP2); // [RA5 = SET Push button (RP2) is assigned to INT2
    PPSInput(PPS_INT3 , PPS_RP7); // [RB4 = OPTO1 CONTACT] (RP7) is assigned to INT3
//    PPSInput(PPS_INT3 , PPS_RP4); // [RB1 = OPTO2 CONTACT] (RP4) is assigned to INT3
    PPSLock();
        
    // Delays are generated by TMR0
    // Timer0 Registers:' 16-Bit Mode; Prescaler=1:2; TMRH Preset=3C; TMRL Preset=B0; Freq=100,00Hz; Period=10,00 ms
    T0CONbits.TMR0ON = 1;               // Timer0 On/Off Control bit:1=Enables Timer0 / 0=Stops Timer0
    T0CONbits.T08BIT = 0;               // Timer0 8-bit/16-bit Control bit: 1=8-bit timer/counter / 0=16-bit timer/counter
    T0CONbits.T0CS   = 0;               // TMR0 Clock Source Select bit: 0=Internal Clock (CLKO) / 1=Transition on T0CKI pin
    T0CONbits.T0SE   = 0;               // TMR0 Source Edge Select bit: 0=low/high / 1=high/low

    // TMR0
    INTCONbits.TMR0IF = 0;              // Clear the TMR0 overflow interrupt flag.
    INTCONbits.TMR0IE = 1;              // Enable TMR0 overflow interrupt

    // RB0 interrupt on falling edge    // nIRQ RFM Module : if that pins goes Low, an HF reception comes up from HF module -> goto ISR
    INTCON2bits.INTEDG0 = 0;            // Interrupt on falling edge
    INTCONbits.INT0IE = 1;              // Enable the INT0 external interrupt (RB0)
    INTCONbits.INT0IF = 0;              // Clears INT0 External Interrupt Flag bit
    
    // RB5 has been mapped to INT1      // ILS Door contact Sensor
    INTCON2bits.INTEDG1 = 1;            // Interrupt on rising edge
    INTCON3bits.INT1IE = 1;             // enable interrupt
    INTCON3bits.INT1IF = 0;             // Clears INT1 External Interrupt Flag bit

    // RA5 has been mapped to INT2      // SET Push Button sends IDENT to receiver
    INTCON2bits.INTEDG2 = 0;            // Interrupt on falling edge
    INTCON3bits.INT2IE = 1;             // enable interrupt
    INTCON3bits.INT2IF = 0;             // Clears INT1 External Interrupt Flag bit
       
    // Set interrupts levels priorities
    INTCON2bits.TMR0IP = 0;             // TMR0 Overflow Interrupt is Low Priority
    // There   is   no   priority   bit associated  with  INT0;  It  is  always  a  high-priority interrupt source
    INTCON3bits.INT1IP = 0;             // INT1 Interrupt is Low Priority
    INTCON3bits.INT2IP = 0;             // INT2 Interrupt is Low Priority
    INTCON2bits.INT3IP = 0;             // INT3 Interrupt is Low Priority
       
    // Disable unused functions
    INTCON2bits.RBPU = 1;               // Disable internal PORTB pull-ups
    PIE1bits.SSPIE = 0;                 // Disable the SPI Interrupt
    PIE1bits.CCP1IE = 0;                // Disable the CCP1 interrupt.
    PIE2bits.TMR3IE = 0;                // Disable TMR3 overflow interrupt.
    INTCONbits.RBIE = 0;                // Disable the RB port change interrupt
    
    # if defined(USE_UART)
    // See datasheet page 215

    // Initialise the serial port
    TRISCbits.TRISC7 = 1;               // RC7 is input  (UART Rx pin)  
    TRISCbits.TRISC6 = 0;               // RC6 is output (UART Tx pin)

    BAUDCONbits.BRG16 = 0;
    SPBRG  = 25;                        // 9600 Bauds
    SPBRGH = 0;

    // Set Transmit function
    TXSTA = 0b10100000;   // 0xA0
    // TXSTA : CSRC TX9 TXEN SYNC SENDB BRGH TRMT TX9D
        // 7   Async mode
        // 6   8 bit selection
        // 5   Enable TX
        // 4   SYNC : Async mode
        // 3   not implemented
        // 2   BRGH = 0
        // 1   don't care   
        // 0   don't care

    // Set Receive function
    RCSTA = 0b10110000; //0xB0
    // RCSTA SPEN RX9 SREN CREN ADDEN FERR OERR RX9D
        // 7   SPEN - Serial Port Enable
        // 6   8 bit selection
        // 5   Asynchronous mode: Don't care
        // 4   CREN - Enable continuous receive
        // 3   disable address detection
        // 2-0 don't care

    IPR1bits.RCIP = 0;      // EUSART Receive Interrupt has low interrupt priority.
    PIE1bits.RCIE = 0;      // Disable USART Receive interrupt
    PIR1bits.RCIF = 0;      // Clear the UART RX interrupt flag
     
    #endif  // (USE_UART)
   
    // If we use SLEEP mode, we need to enable interrupts in order to wake-up the PIC from INT0 and INT1
    
    // the wake-up program execution point is dependent on the state of the GIE bit(s):
    // SET you go to the ISR, CLEAR you continue after the SLEEP instruction.
    
    INTCONbits.INT0IE = 1;       
    INTCON3bits.INT1IE = 1;
    
    // Enable PIC interrupts
    RCONbits.IPEN = 1;                  // Enable priority levels on interrupts. (IPEN: Interrupt Priority Enable bit)
    INTCONbits.GIEL = 1;                // Enable all low priority interrupts.
    INTCONbits.GIEH = 1;                // Enable all high priority interrupts.
    
    // If battery voltage gets low, MCP1257 will turn RC2 to Ground
    if (LOW_BAT == 0) LED = 1;
    else LED = 0;
      
    // If we use Deep Sleep, release deep sleep freeze of GPIO pins
    DSCONLbits.RELEASE = 0; // Clearing this bit will release the I/O pins and allow their respective TRIS and LAT bits to control their states

    switch (ResetType)
    {
        case ePOR:              /* Power on reset, hello there */
            break;
        case eDSWDTO:           /* DSWDT timeout wake from deep sleep */
            SYSTEM_BLUE_LED ^= 1; /* toggle on each timeout wake from deep sleep */
            break;
        case eDSWINT0:          /* DSINT0 wake from deep sleep */  
            MODE_LED ^= 1;      /* toggle on each INT0 wake from deep sleep */
            break;
        case eDSPOR:            /* MCLR wake from deep sleep */
            break;
        case eWDTO:             /* WDT reset, never in deep sleep */
            break;
        default:                /*  */
            break;
    };
    /*
     * We loop here in 'light' sleep and wake whan an interrupt asserts.
     * 
     * In deep sleep a Deep Sleep Watch Doog Timeout or a HIGH to LOW
     * edge on the INT0 input takes us out throught the Power On Reset.
     * 
     */
    while (1)   
    {
        /*
         * Note:
         * 
         *  This is a poor implementation for deep sleep behavior.
         * 
         *  The code enters deep sleep as the first thing after
         *  initialization completes. It is likely that no external
         *  event has happened so none of the interrupts will be
         *  serviced. The code specifically disables all interrupts
         *  except for the INT0 before entering deep sleep. There is
         *  a small window (4 instruction cycles) that if an INT0
         *  event occurs that entry in to deep sleep will fail.
         * 
         *  In any case this should be enough to show how to wake
         *  from deep sleep on the DSWDTO or DSINT0 events.
         * 
         *  To add the DSRTC event requires initializing the RTCC 
         *  and setting up an alarm to assert the RTCC interrupt.
         */
        if (gRequestLightSleep == 0)
        {
            RFM_SHUTDOWN = 1;               // Keep RFM22 is in shutdown mode

            /* enter deep sleep code */
            INTCON  &= ~0xF8;             /* Disable all interrupt sources */
            INTCON3 &= ~0x38;
            PIE1 = 0;
            PIE2 = 0;
            PIE3 = 0;
            PIE4 = 0;
            PIE5 = 0;

            TRISBbits.TRISB0 = 1;   /* Make RB0/INT0 an input */
            ANCON1bits.PCFG8 = 1;   /* Make RB0/INT0 a digital input */
            OSCCONbits.IDLEN = 0;
            WDTCONbits.SWDTEN = 1;  /* Enable the regular Watch Dog Time out too */
            WDTCONbits.REGSLP = 1;
            INTCON2bits.INTEDG0 = 0; /* Select HIGH to LOW edge for interrupt */
            INTCONbits.INT0IF = 0;  /* Clear the INT0 reauest flag */
            INTCONbits.INT0IE = 1;  /* Enable an INT0 assert to wake from sleep */
            DSCONHbits.DSEN = 1;
            Nop();
            Sleep();

            /*
             * If we get to deep sleep the only way out
             * is through the reset vector.
             * 
             * When we do not get to deep sleep we toggle the MODE LED and hang
             * until the regular sleep mode WDT causes a reset.
             */
            for(;;)
            {
                MODE_LED ^= 1; /* Toggle MODE LED and hang to show we failed to enter deep sleep */
            }
        }
        else
        {
            // Goto regular SLEEP Mode : DSEN = 0   ( DEEP SLEEP would not permit to wake-up from INT1 & INT2)
            RFM_SHUTDOWN = 1;               // Keep RFM22 is in shutdown mode

            WDTCONbits.REGSLP = 1;          // On-chip regulator enters low-power operation when device enters Sleep mode     
            OSCCONbits.IDLEN = 0;           // Device enters Sleep mode on SLEEP instruction

            // Deep Sleep mode is entered on a SLEEP command, must be set just before executing Sleep();
            DSCONHbits.DSEN = 0;            //  1 = Deep Sleep mode is entered on a SLEEP command
                                            //  0 = Sleep mode is entered on a SLEEP command
            SLEEP();                        // Sleep and wait for a wake up event
        }
        // SET pushbutton has been pressed, INT2 port change detected it, process tasks here
        if (TRANSMIT_IDENT == 1)
        {    
            INTCON3bits.INT1IE = 0; 
            INTCON3bits.INT3IE = 0;

            // when 'SET' pushbutton was pressed by a user, do things here
            Flashes_BLUE_LED_xtimes(5);

            TRANSMIT_IDENT = 0;
        }    

        // ILS Door Contact has been pressed, INT1 port change detected it, process tasks here                                            
        // when the door is closed, ILS contact provides 3.3V voltage to RB5
        // when the door is open, ILS contact ties RB5 to ground.

        if (DOOR_OPEN == TRUE && SEND_DOOR_REPORT == TRUE)       
        {          
            INTCON3bits.INT2IE = 0;     // Avoid any other input to interrupt this loop
            INTCON3bits.INT3IE = 0;            

            // Do things here
            Flashes_GREEN_LED_xtimes(5);

            SEND_DOOR_REPORT = FALSE;

            INTCON3bits.INT2IE = 1;     // Enable Interrupt
            INTCON3bits.INT3IE = 1;

        }
    }       // while(1) 
}           // void main(void)
