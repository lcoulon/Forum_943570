/*
 * File:   main.c
  */

#include <xc.h>                 // Include the search_result file needed by the compiler
//#include "pps.h"              // Use PPS.h from project folder (not from library) (datasheet p159)
#include <pps.h>                // Use PPS.h 
#include "hardware.h"
#include "extra.h"
#include "interrupts.h"

#include <stdio.h>
#include <stdlib.h>             // Needed for itoa function
#include <string.h>             // Needed for strncpy function
#include <stdint.h>


// PIC 18F26J13 uses internal oscillator @ 4 Mhz with 4X PLL for 16MHz sys clock
#pragma config WDTEN = OFF, PLLDIV = 2, CFGPLLEN = OFF, STVREN = ON
#pragma config XINST = OFF, CP0 = OFF, OSC = INTOSC, SOSCSEL = DIG
#pragma config CLKOEC = OFF, FCMEN = OFF, IESO = ON, WDTPS = 1024
#pragma config DSWDTOSC = INTOSCREF, RTCOSC = INTOSCREF, DSBOREN = OFF
#pragma config DSWDTEN = ON, DSWDTPS = 2048, IOL1WAY = OFF, ADCSEL = BIT12
#pragma config PLLSEL = PLL4X, MSSP7B_EN = MSK7, WPFP = PAGE_127
#pragma config WPCFG = OFF, WPDIS = OFF, WPEND = PAGE_WPFP


/*******************************************************/
/*  Provides information regarding the type of RESET   */
/*******************************************************/
unsigned char ResetType;
        
        
#if defined(USE_UART)
//#include "UART.h"            // use local uart.c & uart.h
#include <usart.h>             // plib Library file
#endif


 /****************************************************************************************************
 *
 *  INTERRUPT functions
 *
 ***************************************************************************************************/
void interrupt low_priority LowISR(void)               
{
NOP();
seconds_counter_TMR0();
ILS_Input_Detected();   // RB5 (RP8) is assigned to INT1
SET_Button_IDENT();     // RA5 (RP2) is assigned to INT2
}

        
void interrupt high_priority HighISR(void)
{
NOP();
#if defined(USE_RFM)
HF_Rx_IT();
#endif    
}
/***************************************************************************************************/

extern BOOL TRANSMIT_IDENT;
extern BOOL DOOR_OPEN;
extern BOOL SEND_DOOR_REPORT;


void main(void)
{        
    OSCCON = 0b01100000;    /* Set internal oscillator to 4MHz wit PLL4X as defined in config words */
    OSCTUNEbits.PLLEN = 1;  /* Turn on PLL for a 16MHz system oscillator */

    for (int i=0; i<300; i++) __delay_ms(10);       // Wait for voltages to stabilize at start-up
       
    ADCON0 = (0b00000000);   // ADON=0, Channel 0, Disable AD converter
    ANCON0 = (0b11111111);   // DS page 371 Pins configured as a digital port
    ANCON1 = (0b00011111);   // DS page 368 Pins configured as a digital port
    
    CM1CON        = 0b00000000; // Turn off all comparators
    CM2CON        = 0b00000000;
    CM3CON        = 0b00000000;
    CVRCON        = 0b00000000;
    
    // Added for Deep Sleep Watchdog Timer
    DSCONHbits.DSULPEN = 0; // ULPWU module is disabled in Deep Sleep
    DSCONHbits.RTCWDIS = 1; // Wake-up from RTCC is disabled
       
    RFM_SHUTDOWN_TRIS = 0;   // RFM22 shutdown pin is output
    RFM_SHUTDOWN = 1;        // Keep RFM22 is in shutdown mode
    
    /* PIN RE-MAPPING*/
    PPSUnLock();
    PPSInput(PPS_INT1 , PPS_RP8); // [RB5 = ILS CONTACT] (RP8) is assigned to INT1
    PPSInput(PPS_INT2 , PPS_RP2); // [RA5 = SET Push button (RP2) is assigned to INT2
    PPSInput(PPS_INT3 , PPS_RP7); // [RB4 = OPTO1 CONTACT] (RP7) is assigned to INT3
//    PPSInput(PPS_INT3 , PPS_RP4); // [RB1 = OPTO2 CONTACT] (RP4) is assigned to INT3
    PPSLock();
        
    SLEEP_DC_TRIS = 0;
    SLEEP_DC = 1;
    
    MODE_LED_TRIS = 0;
    MODE_LED = 0;
   
	LED_TRIS = 0;	
    LED = 0;      
    
    SYSTEM_BLUE_LED_TRIS = 0;
    SYSTEM_BLUE_LED = 0;
    
    RELAY_TRIS = 0;    
    RELAY = 0;
    
    BUZZER_TRIS = 0;  
    BUZZER = 0;
    
    ILS_TRIS = 1;  
    IDENT_TRIS = 1;
    INPUT_1 = 1;
    INPUT_2 = 1;
    
    LOW_BAT = 1;
    RFM_nIRQ_TRIS = 1;                // nIRQ is an input
     
    // Delays are generated by TMR0
    // Timer0 Registers:' 16-Bit Mode; Prescaler=1:2; TMRH Preset=3C; TMRL Preset=B0; Freq=100,00Hz; Period=10,00 ms
    T0CONbits.TMR0ON = 1;               // Timer0 On/Off Control bit:1=Enables Timer0 / 0=Stops Timer0
    T0CONbits.T08BIT = 0;               // Timer0 8-bit/16-bit Control bit: 1=8-bit timer/counter / 0=16-bit timer/counter
    T0CONbits.T0CS   = 0;               // TMR0 Clock Source Select bit: 0=Internal Clock (CLKO) / 1=Transition on T0CKI pin
    T0CONbits.T0SE   = 0;               // TMR0 Source Edge Select bit: 0=low/high / 1=high/low

    // TMR0
    INTCONbits.TMR0IF = 0;              // Clear the TMR0 overflow interrupt flag.
    INTCONbits.TMR0IE = 1;              // Enable TMR0 overflow interrupt

    // RB0 interrupt on falling edge    // nIRQ RFM Module : if that pins goes Low, an HF reception comes up from HF module -> goto ISR
    INTCON2bits.INTEDG0 = 0;            // Interrupt on falling edge
    INTCONbits.INT0IE = 1;              // Enable the INT0 external interrupt (RB0)
    INTCONbits.INT0IF = 0;              // Clears INT0 External Interrupt Flag bit
    
    // RB5 has been mapped to INT1      // ILS Door contact Sensor
    INTCON2bits.INTEDG1 = 1;            // Interrupt on rising edge
    INTCON3bits.INT1IE = 1;             // enable interrupt
    INTCON3bits.INT1IF = 0;             // Clears INT1 External Interrupt Flag bit

    // RA5 has been mapped to INT2      // SET Push Button sends IDENT to receiver
    INTCON2bits.INTEDG2 = 0;            // Interrupt on falling edge
    INTCON3bits.INT2IE = 1;             // enable interrupt
    INTCON3bits.INT2IF = 0;             // Clears INT1 External Interrupt Flag bit
       
    // Enable PIC interrupts
    RCONbits.IPEN = 1;                  // Enable priority levels on interrupts. (IPEN: Interrupt Priority Enable bit)
    INTCONbits.GIEH = 1;                // Enable all high priority interrupts.
    INTCONbits.PEIE_GIEL = 1;           // Enable all low priority interrupts.
    
    // Set interrupts levels priorities
    INTCON2bits.TMR0IP = 0;             // TMR0 Overflow Interrupt is Low Priority
    // There   is   no   priority   bit associated  with  INT0;  It  is  always  a  high-priority interrupt source
    INTCON3bits.INT1IP = 0;             // INT1 Interrupt is Low Priority
    INTCON3bits.INT2IP = 0;             // INT2 Interrupt is Low Priority
    INTCON2bits.INT3IP = 0;             // INT3 Interrupt is Low Priority
       
    // Disable unused functions
    INTCON2bits.RBPU = 1;               // Disable internal PORTB pull-ups
    PIE1bits.SSPIE = 0;                 // Disable the SPI Interrupt
    PIE1bits.CCP1IE = 0;                // Disable the CCP1 interrupt.
    PIE2bits.TMR3IE = 0;                // Disable TMR3 overflow interrupt.
    INTCONbits.RBIE = 0;                // Disable the RB port change interrupt
    
	# if defined(USE_UART)
	// See datasheet page 215

	// Initialise the serial port
	TRISCbits.TRISC7 = 1;               // RC7 is input  (UART Rx pin)	
	TRISCbits.TRISC6 = 0;               // RC6 is output (UART Tx pin)

	BAUDCONbits.BRG16 = 0;
	SPBRG  = 25;                        // 9600 Bauds
	SPBRGH = 0;

	// Set Transmit function
	TXSTA =	0b10100000;   // 0xA0
	// TXSTA : CSRC TX9 TXEN SYNC SENDB BRGH TRMT TX9D
		// 7   Async mode
		// 6   8 bit selection
		// 5   Enable TX
		// 4   SYNC : Async mode
		// 3   not implemented
		// 2   BRGH = 0
		// 1   don't care	
		// 0   don't care

	// Set Receive function
	RCSTA = 0b10110000;	//0xB0
	// RCSTA SPEN RX9 SREN CREN ADDEN FERR OERR RX9D
		// 7   SPEN - Serial Port Enable
		// 6   8 bit selection
		// 5   Asynchronous mode: Don't care
		// 4   CREN - Enable continuous receive
		// 3   disable address detection
		// 2-0 don't care

 	IPR1bits.RCIP = 0;      // EUSART Receive Interrupt has low interrupt priority.
	PIE1bits.RCIE = 0;		// Disable USART Receive interrupt
	PIR1bits.RCIF = 0;		// Clear the UART RX interrupt flag
     
	#endif	// (USE_UART)

   
    
    // If battery voltage gets low, MCP1257 will turn RC2 to Ground
    if (LOW_BAT == 0) LED = 1;
    else LED = 0;
      
    
    // If we use SLEEP mode, we need to enable interrupts in order to wake-up the PIC from INT0 and INT1
    
    // the wake-up program execution point is dependent on the state of the GIE bit(s):
    // SET you go to the ISR, CLEAR you continue after the SLEEP instruction.
    
    INTCONbits.INT0IE = 1;       
    INTCON3bits.INT1IE = 1;
    INTCONbits.GIEH = 1;

    
    // If we use Deep Sleep, release deep sleep freeze of GPIO pins
    DSCONLbits.RELEASE = 0; // Clearing this bit will release the I/O pins and allow their respective TRIS and LAT bits to control their states

    
    ResetType = check_reset(); 

    switch (ResetType)
    {
        case 0: /* Power on reset, hello there */
            break;
            
        case 1: /* DSWDT timeout wake from deep sleep */
            SYSTEM_BLUE_LED ^= 1; /* toggle on each wake from deep sleep */
            break;
            
        case 2: /* MCLR wake from deep sleep */
            break;
            
        case 3: /* WDT reset, never in deep sleep */
            break;
            
        default: /*  */
            break;
    };
    
     
            /* enter deep sleep code */
            RFM_SHUTDOWN = 1;               // Keep RFM22 is in shutdown mode

            WDTCONbits.REGSLP = 1;          // On-chip regulator enters low-power operation when device enters Sleep mode     
            OSCCONbits.IDLEN = 0;           // Device enters Sleep mode on SLEEP instruction

            // Deep Sleep mode is entered on a SLEEP command, must be set just before executing Sleep();
            DSCONHbits.DSEN = 0;            //  1 = Deep Sleep mode is entered on a SLEEP command
                                            //  0 = Sleep mode is entered on a SLEEP command
            SLEEP();
    
            
            
            // for sleep mode, execution will resume here
            // for deep sleep, execution will restart at reset vector (use WDTCONbits.DS to detect)
           
            
            // The following tasks will be done only after SLEEP mode wake-up,
            // these should not be executed if PIC wakes-up from DEEP SLEEP
            
            /*
             * If we get to deep sleep the only way out
             * is through the reset vector.
             * 
             * When we do not get to deep sleep, light MODE_LED to inform deep sleep mode has not been entered
             */
            MODE_LED = 1; /* assert deep sleep entry failed */

            

            // SET pushbutton has been pressed, INT2 port change detected it, process tasks here
            if (TRANSMIT_IDENT == 1)
            {    
                INTCON3bits.INT1IE = 0; 
                INTCON3bits.INT3IE = 0;

                // when 'SET' pushbutton was pressed by a user, do things here
                Flashes_BLUE_LED_xtimes(5);

                TRANSMIT_IDENT = 0;
            }    


            // ILS Door Contact has been pressed, INT1 port change detected it, process tasks here                                            
            // when the door is closed, ILS contact provides 3.3V voltage to RB5
            // when the door is open, ILS contact ties RB5 to ground.

            if (DOOR_OPEN == TRUE && SEND_DOOR_REPORT == TRUE)       
            {          
                INTCON3bits.INT2IE = 0;     // Avoid any other input to interrupt this loop
                INTCON3bits.INT3IE = 0;            

                // Do things here
                Flashes_GREEN_LED_xtimes(5);

                SEND_DOOR_REPORT = FALSE;

                INTCON3bits.INT2IE = 1;     // Enable Interrupt
                INTCON3bits.INT3IE = 1;
                           
            }
            
            
            // Goto regular SLEEP Mode : DSEN = 0   ( DEEP SLEEP would not permit to wake-up from INT1 & INT2)
            RFM_SHUTDOWN = 1;               // Keep RFM22 is in shutdown mode

            WDTCONbits.REGSLP = 1;          // On-chip regulator enters low-power operation when device enters Sleep mode     
            OSCCONbits.IDLEN = 0;           // Device enters Sleep mode on SLEEP instruction

            // Deep Sleep mode is entered on a SLEEP command, must be set just before executing Sleep();
            DSCONHbits.DSEN = 0;            //  1 = Deep Sleep mode is entered on a SLEEP command
                                            //  0 = Sleep mode is entered on a SLEEP command
            SLEEP();            
            
    
    
    while (1)
    {
        
    }       // while(1) 
}           // void main(void)
